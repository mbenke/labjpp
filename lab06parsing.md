## Przygotowanie

Na własnym komputerze:

* o ile ktoś instalował GHC przy użyciu `ghcup` (patrz Lab Haskell 0), można zainstalować BNFC używając polecenia

```
cabal install --lib array
cabal install alex happy BNFC
```

Domyślnie programy są instalowane w `$HOME/.cabal/bin/`

* o ile ktoś instalował GHC przy użyciu `stack` (patrz Lab Haskell 0), mozna zainstalować BNFC uzywając polecenia

```
stack install alex happy BNFC
```

Domyślnie programy są instalowane w `$HOME/.local/bin/`

BNFC jest też dostępny na stronie [https://bnfc.digitalgrammars.com/](https://bnfc.digitalgrammars.com/)

Dokumentacja: [https://bnfc.readthedocs.io](https://bnfc.readthedocs.io)

W razie problemów polecam pracę na `students`, gdzie jest zainstalowany BNFC, oraz inne potrzebne narzędzia (alex, happy).

* Uruchom przykładowy parser w BNFC  z wykładu:

```
$ cabal install alex happy BNFC

$ cat Exp0.cf
EAdd . Exp  ::= Exp "+" Exp1;
_    . Exp  ::= Exp1;
EInt . Exp1 ::= Integer;

$ bnfc -m Exp0.cf
2 rules accepted
...
writing new file ./Makefile

$ make
alex --ghc LexExp.x
happy --ghc --coerce --array --info ParExp.y
ghc --make TestExp.hs -o TestExp
...
Linking TestExp ...


$ echo "2+2" | ./TestExp

Parse Successful!

[Abstract Syntax]

EPlus (EInt 2) (EInt 2)

[Linearized tree]

2 + 2
```
* Przy pomocy `Text.Parsec` uruchomić `pNat`, `pInt` z wykładu:

```
import Text.ParserCombinators.Parsec
import Data.Char(isDigit,digitToInt)

run :: Parser a -> [Char] -> Either ParseError a
run p s = parse p "(interactive)" s

pDigit :: Parser Int
pDigit = satisfy isDigit >>= return . digitToInt
-- pDigit = fmap digitToInt digit

pDigits :: Parser [Int]
pDigits = many1 pDigit

pNat :: Parser Integer
pNat = fmap (foldl (\x y -> 10*x+(toInteger y)) 0) pDigits

pInt :: Parser Integer
pInt = negative pNat <|> pNat where
  negative :: (Num a) => Parser a -> Parser a
  negative p = fmap negate (char '-' >> p)


-- >>> run pNat "123 ala"
-- Right 123
-- >>> run pNat "-123 ala"
-- Left "(interactive)" (line 1, column 1):
-- unexpected "-"
-- >>> run pInt "-123 ala"
-- Right (-123)
```

* Uruchom parser dla wyrażeń arytmetycznych z wykładu (używający parsec)

## Zadanie 1
Dana składnia abstrakcyjna wyrażeń arytmetycznych (jak w 2. tygodniu)

    data Exp 
      = EInt Int             -- stała całkowita       
      | EAdd Exp Exp         -- e1 + e2
      | ESub Exp Exp         -- e1 - e2
      | EMul Exp Exp         -- e1 * e2
      | EVar String          -- zmienna
      | ELet String Exp Exp  -- let var = e1 in e2

a. zaprojektuj składnię konkretną
Sugestie: standardowa notacja infiksowa oraz notacja prefiksowa a la Lisp: (* (+ 1 2) 3)

b. Napisz i uruchom parser dla powyższej składni konkrentej przy użyciu BNFC  (składnia abstrakcyjna nie musi być idetyczna, BNFC w pewnym sensie narzuca składnię abstrakcyjną).

c. Połącz z napisanym wcześniej ewaluatorem takich wyrażeń.

<!--
c. napisz parser dla tej składni przy uzyciu `Text.Parsec`

UWAGA: Ze względów wydajnościowych, operator (<|>) z biblioteki Parsec
jest prawie deterministyczny i nie będzie działać dobrze dla
produkcji, które mają wspólny (niepusty) prefiks.

Możemy odzyskać niedeterminizm przy pomocy kombinatora try, np.

    try p <|> q
-->

## Zadanie 2
Napisz parser dla swojego języka (dowolną techniką). Dla parsera LR (BNFC, Happy, etc.) zwróć uwagę na konflikty.

## Analiza konfliktów

```
$ cat BadExp.cf
EInt . Exp ::= Integer;
EAdd . Exp ::= Exp "+" Exp ;
$ bnfc -m BadExp.cf
...
bash-3.2$ happy -gca --info=bad.txt ParBadExp.y
unused terminals: 1
shift/reduce conflicts:  1
$ cat bad.txt
Info file generated by Happy Version 1.19.4 from ParBadExp.y

state 6 contains 1 shift/reduce conflicts.

terminal L_err is unused
...
State 6

	Exp -> Exp . '+' Exp                                (rule 3)
	Exp -> Exp '+' Exp .                                (rule 3)

	'+'            shift, and enter state 5
			(reduce using rule 3)

	%eof           reduce using rule 3

$ sed  's/--array --info --ghc --coerce/--array --info --ghc --coerce --debug/' Makefile > Makefile.debug
# lub dla starszych wersji BNFC
$ sed  's/happy -gca/happy -gcad/' Makefile > Makefile.debug

$ make -f Makefile.debug
$ echo "1+2+3" | ./TestBadExp
state: 0,	token: 2,	action: shift, enter state 2
state: 2,	token: 1,	action: reduce (rule 1), goto state 3
state: 3,	token: 1,	action: reduce (rule 2), goto state 4
state: 4,	token: 1,	action: shift, enter state 5
state: 5,	token: 2,	action: shift, enter state 2
state: 2,	token: 1,	action: reduce (rule 1), goto state 3
state: 3,	token: 1,	action: reduce (rule 2), goto state 6
state: 6,	token: 1,	action: shift, enter state 5
state: 5,	token: 2,	action: shift, enter state 2
state: 2,	token: 4,	action: reduce (rule 1), goto state 3
state: 3,	token: 4,	action: reduce (rule 2), goto state 6
state: 6,	token: 4,	action: reduce (rule 3), goto state 6
state: 6,	token: 4,	action: reduce (rule 3), goto state 4
state: 4,	token: 4,	action: accept.

Parse Successful!

[Abstract Syntax]

EAdd (EInt 1) (EAdd (EInt 2) (EInt 3))
```
