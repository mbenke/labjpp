## Zadanie 1.
a. Napisz lekser dla składni konkretnej wyrażeń zaprojektowanej w
poprzednim tygodniu.

b. Zmodyfikuj swoj parser tak by działał na poziomie leksemów, a nie
pojedynczych znaków.

c. Rozszerz lekser i parser o literały dla liczb zmiennoprzecinkowych
(wystarczy format 123.456, ale dla bardziej ambitnych także 1.2e-3)

## Zadanie 2
Napisz parser dla składni konkretnej wyrażeń zaprojektowanej w
poprzednim tygodniu przy uzyciu BNFC (lub, jeśli ktoś bardzo chce,
innego generatora parserów). 

Składnia abstrakcyjna może być nieco inna
(np. BNFC w pewnym sensie narzuca składnię abstrakcyjną).

## Zadanie 3

Napisz parser dla swojego języka (dowolną techniką). Dla parsera LR (BNFC, Happy, etc.) zwróć uwagę na konflikty.

## Analiza konfliktów

```
$ cat BadExp.cf
EInt . Exp ::= Integer;
EAdd . Exp ::= Exp "+" Exp ;
$ bnfc -m BadExp.cf
...
bash-3.2$ happy -gca --info=bad.txt ParBadExp.y
unused terminals: 1
shift/reduce conflicts:  1
$ cat bad.txt
Info file generated by Happy Version 1.19.4 from ParBadExp.y

state 6 contains 1 shift/reduce conflicts.

terminal L_err is unused
...
State 6

	Exp -> Exp . '+' Exp                                (rule 3)
	Exp -> Exp '+' Exp .                                (rule 3)

	'+'            shift, and enter state 5
			(reduce using rule 3)

	%eof           reduce using rule 3


$ sed  s/-gca/-gcad/ Makefile > Makefile.debug
$ make -f Makefile.debug
$ echo "1+2+3" | ./TestBadExp
state: 0,	token: 2,	action: shift, enter state 2
state: 2,	token: 1,	action: reduce (rule 1), goto state 3
state: 3,	token: 1,	action: reduce (rule 2), goto state 4
state: 4,	token: 1,	action: shift, enter state 5
state: 5,	token: 2,	action: shift, enter state 2
state: 2,	token: 1,	action: reduce (rule 1), goto state 3
state: 3,	token: 1,	action: reduce (rule 2), goto state 6
state: 6,	token: 1,	action: shift, enter state 5
state: 5,	token: 2,	action: shift, enter state 2
state: 2,	token: 4,	action: reduce (rule 1), goto state 3
state: 3,	token: 4,	action: reduce (rule 2), goto state 6
state: 6,	token: 4,	action: reduce (rule 3), goto state 6
state: 6,	token: 4,	action: reduce (rule 3), goto state 4
state: 4,	token: 4,	action: accept.

Parse Successful!

[Abstract Syntax]

EAdd (EInt 1) (EAdd (EInt 2) (EInt 3))
```
